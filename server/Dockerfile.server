# ./server/Dockerfile.server

# Use an official Python runtime as a parent image
# Choose a specific version compatible with your project (e.g., 3.9, 3.10, 3.11)
# Using slim-buster provides a good balance between size and compatibility
FROM python:3.9-slim-buster


# Set the working directory in the container
WORKDIR /app/server

# Install system dependencies if needed by your Python packages
# Example: RUN apt-get update && apt-get install -y --no-install-recommends gcc libpq-dev && rm -rf /var/lib/apt/lists/*

# Copy the requirements file first to leverage Docker cache
COPY requirements.txt .

# Install Python dependencies
# --no-cache-dir: Disables the pip cache, reducing image size
# --upgrade pip: Ensures pip is the latest version
# -r requirements.txt: Installs packages listed in the file
RUN pip install --no-cache-dir --upgrade pip -r requirements.txt

# Copy the rest of the application code into the container
# This includes your main.py, models, controllers, etc.
COPY . .

# Expose the port the application will run on
# Ensure this matches the port your web server (Flask, FastAPI, etc.) listens on
# Defaulting to 8000, change if necessary
EXPOSE 8000

# Specify the command to run the application
# This command depends on how your Python application is started

# Option 3: Using Uvicorn for ASGI applications (like FastAPI)
CMD ["uvicorn", "main:app", "--host", "0.0.0.0", "--port", "8000"]
